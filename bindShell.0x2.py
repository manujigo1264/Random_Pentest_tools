#!/usr/bin/env python3

import socket
import subprocess
import logging
import argparse
from threading import Thread

logger = logging.getLogger(__name__)

def run_command(command):
    """Runs a command and returns its output."""
    output = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    return output.stdout

def handle_input(client_socket):
    """Handles incoming commands from the client."""
    try:
        while True:
            chunks = []
            chunk = client_socket.recv(2048)
            chunks.append(chunk)
            while len(chunk) != 0 and chr(chunk[-1]) != '\n':
                chunk = client_socket.recv(2048)
                chunks.append(chunk)
            command = (b''.join(chunks)).decode()[:-1]

            if command.lower() == 'exit':
                client_socket.close()
                logger.info(f'Connection closed.')
                break

            output = run_command(command)
            client_socket.sendall(output)
    except Exception as e:
        logger.error(f'Error occurred while handling input: {e}')
    finally:
        client_socket.close()

def main(port):
    """Starts the server and listens for incoming connections."""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(('0.0.0.0', port))
        s.listen(4)

        logger.info(f'Listening on 0.0.0.0:{port}')

        while True:
            client_socket, client_address = s.accept()
            logger.info(f'Accepted connection from {client_address[0]}:{client_address[1]}')
            t = Thread(target=handle_input, args=(client_socket,))
            t.start()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Simple command execution server')
    parser.add_argument('--port', '-p', type=int, default=8089, help='The port to listen on.')
    args = parser.parse_args()

    logging.basicConfig(level=logging.INFO)

    main(args.port)
